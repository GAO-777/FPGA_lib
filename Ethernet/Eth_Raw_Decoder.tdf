TITLE "Ethernet IPv4 decoder";

INCLUDE "Edge_Sensing_Sync.inc";
INCLUDE "lpm_shiftreg.inc";
INCLUDE "lpm_counter.inc";

Constant PARCER_CYLCLE_WIDTH = 2;--20;
Constant PARCER_CYLCLE_CNT_WIDTH = Ceil(log2(PARCER_CYLCLE_WIDTH))+1;
Constant WORD_WIDTH	= 16; 

CONSTANT PacketLenghts_at_signaling_layer  = 4096;--2048;-- maximum length value in bytes
CONSTANT RxByte_Cnt_Width = Ceil( LOG2(PacketLenghts_at_signaling_layer))-1;

Constant IPv4_type    		    = H"CDCD";

CONSTANT HeaderFrame_Type		= 6;  -- 2 байт тип запроса (ARP или IPv4 или ...)
CONSTANT IP_Header    			= 7;  -- 20 байт (10 слова) для IP заголовка
CONSTANT UDP_Header    			= 17; -- 8 байт (4 слова) для UDP заголовка
CONSTANT RxCommandPath 			= 21; -- номер слова дешифруемое командой
CONSTANT RxDataPath    			= 22; -- номер слова дешифруемое как адрес или данные в зависимости от команды
CONSTANT RxDataWordLenght  		= 2200;--(PacketLenghts_at_signaling_layer div 2)-RxCommandPath-1;
CONSTANT RxByteLenght			= (PacketLenghts_at_signaling_layer div 2)-1;

-- протокольные команды
CONSTANT CMD_PING 	   			= 1; -- команда эхо
CONSTANT CMD_READ_AD 	  		= 2; -- команда чтения адрес,данные,адрес,данные...
CONSTANT CMD_WRITE_AD 	   		= 3; -- команда записи адрес,данные,адрес,данные...
CONSTANT CMD_READ_AA			= 4; -- команда чтения адрес,адрес,адрес,адрес... в ответе данные,данные,данны...
CONSTANT CMD_READ_BLOCK_16 	   	= 5; -- команда чтения адрес, 16 слов данных с автоинкрементом адреса, адрес, 16 слов данных...  
CONSTANT CMD_WRITE_BLOCK_16    	= 6; -- команда запмси адрес, 16 слов данных с автоинкрементом адреса, адрес, 16 слов данных... 



SUBDESIGN Eth_Raw_Decoder
(
  Clock                         : input; -- System Clock, really Bus_Clock

  Rx_Data[WORD_WIDTH-1..0]  	: input;
  Rx_Addr[10..0]  				: output;
  Rx_Parcer_RQ					: input;
  Rx_NUM_Data[10..0]  			: input;
   
  Tx_Addr[10..0]  				: output;
  Tx_Data[WORD_WIDTH-1..0]  	: output;
  Tx_Word_Strobe      			: output;
  
  Reset                         : input;
  
  Rx_Error                      : output;
  Tx_Start				        : output;
  Rx_Parcer_in_progress  		: output;
  Rx_TRUE_RQ		            : output;
  Rx_NOT_RQ                 	: output;
   
  Identification[WORD_WIDTH-1..0] : output;
  DIMA_Ident[WORD_WIDTH-1..0]	: input;
  
  Rx_Packet_Lenght[WORD_WIDTH-1..0] : input;
  
 
  --Сигналы для обмена с Секлеткой внутренней шиной проекта  
  AccessRequest			    	: output;
  AccessGranted			    	: input; 
  DirectOut				    	: output;
  AddrBusOut[15..0]	    		: output;
  DataBus_In[15..0]			    : input;  -- отправляемые с Внутренней Шины в Модуль данные
  DataBusStrobe 			 	: input;  -- строб приема/передачи данных наружу (высокий уровень, защелкиваем по заднему фронту)
 
  test : output;
)
VARIABLE
  Rx_Parcer_RQ_ES               : Edge_Sensing_Sync;
  RxParcerActive                : SRFF;
 -- IPv4_Request        		    : node; -- если опознан ARP запрос то запускаем отправку данных из Tx буффера
  Tx_Start_Pulse_Flag           : SRFF;
 --  Tx_Strobe                     : node;

  ParcerCnt						: LPM_COUNTER WITH (LPM_WIDTH = RxByte_Cnt_Width);
  
  Prescaler                     : LPM_COUNTER WITH (LPM_WIDTH = PARCER_CYLCLE_CNT_WIDTH);
  Pascer_Sample_Enable 			: node;
  
  IPv4_type_True				: node;
  IPv4_type_Flag				: SRFF;
  --IPv4_Err                      : node;
  --IPv4_Err_Flag					: SRFF;
  
  ParcerEndCyle                 : node;
  
  BUS_Direct                    : node; -- мастер выставляет данные на внутреннюю шину(VCC) для записи в ВР или требут данные(GND) от ВР
  Target_Command_Reg  			: LPM_SHIFTREG WITH (LPM_WIDTH = WORD_WIDTH);
  CMD_CS                        : node; -- если опознан ARP запрос то защелкиваем команду, взводим флаг отправки данных из Tx буффера
  Target_Address_Reg			: LPM_SHIFTREG WITH (LPM_WIDTH = WORD_WIDTH);
  ADDR_CS						: node;
  DATA_CS						: node;
  TA_REG_Load					: node;
   
  Access_Request                : SRFF;
  Data_Sent_OK					: node;
  Requiest_Enable     			: node;
  Tx_Word_Strobe_               : node;
  
  Tx_Start_Pulse 				: node;
  Tx_Start_Pulse_EN				: node;     
   
   
  CMD_READ_Status				: node;
  
  Identification_Cnt			: LPM_COUNTER WITH (LPM_WIDTH = WORD_WIDTH);
  
BEGIN
DEFAULTS
	    IPv4_type_True	 	 = GND;
        ParcerEndCyle        = GND;
        CMD_CS               = GND;
        ADDR_CS              = GND;
        DATA_CS              = GND;
END DEFAULTS;

   Prescaler.(clock, sclr) = (Clock, Pascer_Sample_Enable OR Rx_Parcer_RQ_ES.q OR DATA_CS);
   IF (Prescaler.q[] ==  PARCER_CYLCLE_WIDTH-1) THEN  Pascer_Sample_Enable = VCC;
											    ELSE  Pascer_Sample_Enable = GND;
   END IF;

-------------------------------------------- Rx section --------------------------------------------
   Rx_Parcer_RQ_ES.(d,clk)  = (Rx_Parcer_RQ, Clock);
   RxParcerActive.(S,clk,R) = (Rx_Parcer_RQ_ES.q, Clock, ParcerEndCyle OR Reset);
   
   --ParcerCnt.(clock,sload,cnt_en) = (Clock, Rx_Parcer_RQ_ES.q OR ParcerEndCyle, RxParcerActive.q AND Pascer_Sample_Enable);
   ParcerCnt.(clock,sload,cnt_en) = (Clock, Rx_Parcer_RQ_ES.q OR ParcerEndCyle, RxParcerActive.q AND Tx_Word_Strobe_);
   ParcerCnt.data[] = HeaderFrame_Type;
   
   IF(RxParcerActive.q == VCC) THEN
        Tx_Addr[10..0] = ParcerCnt.q[]; 
        IF ((ParcerCnt.q[] == HeaderFrame_Type)   AND (Rx_Data[] == IPv4_type)) THEN  IPv4_type_True = VCC; END IF;
        IF ((ParcerCnt.q[] == HeaderFrame_Type+1) AND (IPv4_type_Flag.q == GND)) THEN ParcerEndCyle = VCC; END IF;  -- если это не IPv4 протокол, то конец работы цикла разборки данных
        IF (ParcerCnt.q[]  == Rx_NUM_Data[10..0]) THEN ParcerEndCyle = VCC; END IF;  -- конец работы цикла разборки данных
   
        
           
         -- заголовок ответа
        Rx_Addr[10..0] = ParcerCnt.q[];
        IF (ParcerCnt.q[] == 6)   THEN  Tx_Data[] = Rx_Data[];  END IF; -- тип пакета 
        -- IP header
        IF (ParcerCnt.q[] == 7)   THEN  Tx_Data[] = H"0001";   	 END IF; 			-- Version
        IF (ParcerCnt.q[] == 8)   THEN  Tx_Data[15..8] = Identification_Cnt.q[7..0]; Tx_Data[7..0] = Identification_Cnt.q[15..8]; END IF; -- Номер пакета (Sequence)
        IF (ParcerCnt.q[] == 9)   THEN  Tx_Data[15..8] = DIMA_Ident[7..0];  Tx_Data[7..0] = DIMA_Ident[15..8]; END IF; -- номер раздела DAQPartition
        IF (ParcerCnt.q[] == 10)  THEN  Tx_Data[] = Rx_Data[];	 END IF; 			-- DAQFCId
        IF (ParcerCnt.q[] == 11)  THEN  Tx_Data[] = Rx_Data[];   END IF; 			-- WORD Reserved
        IF (ParcerCnt.q[] == 12)  THEN  Tx_Data[] = Rx_Data[];   END IF; 			-- WORD Reserved
        IF (ParcerCnt.q[] == 13)  THEN  Tx_Data[] = Rx_Data[];   END IF; 			-- WORD Reserved
		IF (ParcerCnt.q[] == 14)  THEN  Tx_Data[] = Rx_Data[];   END IF; 			-- WORD Reserved
		-- UDP header
		IF (ParcerCnt.q[] == 15)  THEN  Tx_Data[] = Rx_Data[];   END IF; 			-- WORD Reserved
		IF (ParcerCnt.q[] == 16)  THEN  Tx_Data[] = Rx_Data[];   END IF; 			-- WORD Reserved
		IF (ParcerCnt.q[] == 17)  THEN  Tx_Data[] = Rx_Data[];   END IF; 			-- WORD Reserved
		IF (ParcerCnt.q[] == 18)  THEN  Tx_Data[] = Rx_Data[];   END IF; 			-- WORD Reserved
        IF (ParcerCnt.q[] == 19)  THEN  Tx_Data[] = Rx_Data[];   END IF;
        IF (ParcerCnt.q[] == 20)  THEN  Tx_Data[15..8] = Rx_Packet_Lenght[7..0]; Tx_Data[7..0] = Rx_Packet_Lenght[15..8]; END IF; 	-- Payload lenght

   
       
      -- защелкиваем и определяем тип пришедшей команды
        IF (ParcerCnt.q[]==RxCommandPath) THEN CMD_CS = VCC; Tx_Data[] = (Rx_Data[] OR H"0002"); 
										  ELSE CMD_CS = GND;                                   
		END IF;
		IF (ParcerCnt.q[]==RxCommandPath+1) THEN Tx_Start_Pulse = VCC; -- если IP и UDP заголовки правильные то разрешаем
										    ELSE Tx_Start_Pulse = GND; -- по концу работы парсера толкнуть отправку данных из Tx буффера
		END IF;

      -- защелкиваем адрес и данные
      -- дешифрируем данные как адрес,данные...
				IF ((ParcerCnt.q[] >= RxDataPath) AND (ParcerCnt.q[] <= RxByteLenght))   THEN -- адрес, данные, адрес, данные, ... 
					IF (ParcerCnt.q[0] == GND) THEN ADDR_CS = VCC; Tx_Data[] = Rx_Data[]; END IF;
					IF (ParcerCnt.q[0] == VCC) THEN DATA_CS = VCC; Tx_Data[15..8]  = DataBus_In[7..0]; Tx_Data[7..0] = DataBus_In[15..8]; END IF;
				ELSE ADDR_CS = GND; DATA_CS = GND;
				END IF;	
				Requiest_Enable    	=   Pascer_Sample_Enable AND ADDR_CS;
				TA_REG_Load			=   Pascer_Sample_Enable AND ADDR_CS;
       
	
        IF (DATA_CS==VCC) THEN Tx_Word_Strobe_ = Data_Sent_OK;
  						  ELSE Tx_Word_Strobe_ = Pascer_Sample_Enable;
        END IF;
         
	
        IF (DATA_CS==VCC) THEN Tx_Word_Strobe_ = Data_Sent_OK;
  						  ELSE Tx_Word_Strobe_ = Pascer_Sample_Enable;
        END IF;
    
        AddrBusOut[15..0]	=	Target_Address_Reg.q[];
                               ELSE
   
        IPv4_type_True	 	 = GND;
        Rx_Addr[]        	 = GND;
        Tx_Addr[]			 = GND;
        Tx_Data[] 			 = GND; 
        ParcerEndCyle        = GND;
        CMD_CS               = GND;
        ADDR_CS              = GND;
        DATA_CS              = GND;
        AddrBusOut[15..0]	 = GND;
        BUS_Direct 			 = GND;
   END IF;
   
   Identification_Cnt.(clock,cnt_en) = (Clock,Edge_Sensing_Sync(.d=IPv4_type_True,.clk=Clock));

   -- Master Access Control: формируем запрос на внутреннюю шину проекта
   -- отправляем данные на шину проекта
   Access_Request.S  	=	Requiest_Enable; 
   Access_Request.clk 	=  	Clock;
   Access_Request.R  	=	Data_Sent_OK; 
   AccessRequest		=	Access_Request.q;
   DirectOut            =   BUS_Direct;
   
   Data_Sent_OK	        =	DataBusStrobe AND AccessGranted;
   --AddrBusOut[15..0]	=	Target_Address_Reg.q[];
   
   Target_Command_Reg.(clock, enable, load, aclr) = (Clock, CMD_CS  AND Pascer_Sample_Enable, VCC, Rx_Parcer_RQ_ES.q OR Reset);
   Target_Command_Reg.data[15..8] = Rx_Data[7..0]; Target_Command_Reg.data[7..0] = Rx_Data[15..8];
   Target_Address_Reg.(clock, enable, load, aclr) = (Clock, TA_REG_Load, VCC, Rx_Parcer_RQ_ES.q OR Reset);
   Target_Address_Reg.data[15..8] = Rx_Data[7..0]; Target_Address_Reg.data[7..0] = Rx_Data[15..8];
   
   CASE (Target_Command_Reg.q[] AND H"00FF")IS  -- анализируем младший байт, определяем тип команды
			WHEN CMD_READ_AD		=>  BUS_Direct = GND; CMD_READ_Status = GND;
			WHEN CMD_WRITE_AD 		=>	BUS_Direct = VCC; CMD_READ_Status = GND;	
			WHEN CMD_READ_AA		=>  BUS_Direct = GND; CMD_READ_Status = VCC;
			WHEN OTHERS			    =>  BUS_Direct = GND; CMD_READ_Status = GND;
   END CASE;
   IF(Target_Command_Reg.q[15..8] == 2) THEN Tx_Start_Pulse_EN = GND; -- анализируем старший байт, определяем входящаяя или возвращенная посылка
                                        ELSE Tx_Start_Pulse_EN = VCC;
   END IF;
   
   -- флаги
   IPv4_type_Flag.(S,clk,R)       = (IPv4_type_True, Clock, Rx_Parcer_RQ_ES.q OR Reset);
   Tx_Start_Pulse_Flag.(S,clk,R)  = (Tx_Start_Pulse_EN AND Tx_Start_Pulse, Clock, Rx_Parcer_RQ_ES.q OR Reset OR ParcerEndCyle);
   
   -- выходы
   Rx_Error		          = GND;
   Rx_NOT_RQ              = (!IPv4_type_Flag.q) AND ParcerEndCyle;
   Tx_Start				  = Tx_Start_Pulse_Flag.q AND ParcerEndCyle;
   Rx_Parcer_in_progress  = RxParcerActive.q;
   Tx_Word_Strobe         = RxParcerActive.q AND Tx_Word_Strobe_;
   Rx_TRUE_RQ             = IPv4_type_Flag.q AND ParcerEndCyle;
   
   Identification[]		  = Identification_Cnt.q[];
   
   test = IPv4_type_Flag.q;
END;